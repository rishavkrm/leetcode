func minMalwareSpread(graph [][]int, initial []int) int {
    sort.Slice(initial, func(i int, j int)bool{
        return initial[i] < initial[j]
    })
	if len(initial) == 1 {
		return initial[0]
	}
	g := map[int][]int{}
	n := len(graph)
	for i := 0; i < n; i++ {
		g[i] = make([]int, 0)
	}
	for i := 0; i < len(graph); i++ {
		for j := 0; j < len(graph[0]); j++ {
			if i != j && graph[i][j] == 1 {
				g[i] = append(g[i], j)
			}
		}
	}
	currMax := -1
	currIndex := 0
	fmt.Println(g)
	for i, node := range initial {
		temp := nInfected(g, node, initial)
		if temp > currMax {
			currIndex = i
			currMax = temp
		}
		fmt.Println(node, temp)
	}
	return initial[currIndex]
}

func nInfected(graph map[int][]int, node int, initial []int) int {
	parent := make([]int, len(graph))
	rank := make([]int, len(graph))
	for i := 0; i < len(graph); i++ {
		parent[i] = i
	}
	for i := 0; i < len(graph); i++ {
		for _, j := range graph[i] {
			union(i, j, &parent, &rank)
		}
	}
	init2 := []int{}
	for i := 0; i < len(initial); i++ {
		if initial[i] != node {
			init2 = append(init2, initial[i])
		}
	}
	initial = init2
	z := initial[0]
	for i := range len(initial) {
		union(z, initial[i], &parent, &rank)
	}

	for i := range len(initial) {
		currNode := initial[i]
		for _, nbr := range graph[currNode] {
			union(currNode, nbr, &parent, &rank)
		}
	}
	res := 0
	for xx := range len(graph) {
		if find(xx, &parent) != find(z, &parent) {
			res += 1
		}
	}
	return res
}

func find(k int, parent *[]int) int {
	if !((*parent)[k] == k) {
		(*parent)[k] = find((*parent)[k], parent)
	}
	return (*parent)[k]
}
func union(x1 int, x2 int, p *[]int, r *[]int) {
	x1Parent := find(x1, p)
	x2Parent := find(x2, p)
	if x1Parent == x2Parent {
		return
	}
	if (*r)[x1Parent] > (*r)[x2Parent] {
		(*p)[x2Parent] = x1Parent
	} else if (*r)[x1Parent] < (*r)[x2Parent] {
		(*p)[x1Parent] = x2Parent
	} else {
		(*p)[x1Parent] = x2Parent
		(*r)[x2Parent] += 1
	}
}